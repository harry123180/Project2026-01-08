<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ë≤ìË≤ìÁ•ûÂ∞ÑÊâã (Cat Shooter)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f4f8;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border-radius: 12px;
            overflow: hidden;
            background: #fff;
        }

        canvas {
            display: block;
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA); /* Sky background */
            cursor: crosshair;
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            color: #333;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #fff;
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            display: none; /* Hidden by default */
        }

        h1 { margin-bottom: 10px; font-size: 32px; color: #FFD700; text-shadow: 2px 2px 0 #000; }
        p { font-size: 24px; margin-bottom: 20px; }
        
        button {
            padding: 12px 30px;
            font-size: 20px;
            background-color: #FF6B6B;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s, background-color 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        button:hover {
            background-color: #FF5252;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        .instruction {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: #555;
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="600" height="800"></canvas>
    
    <div id="ui-layer">
        ÂàÜÊï∏: <span id="scoreDisplay">0</span>
    </div>

    <div id="game-over-screen">
        <h1>ÈÅäÊà≤ÁµêÊùü!</h1>
        <p>‰Ω†ÁöÑÂæóÂàÜ: <span id="finalScore">0</span></p>
        <button id="restartBtn">ÂÜçÁé©‰∏ÄÊ¨°</button>
    </div>

    <div class="instruction">
        ÊªëÈº†ÁßªÂãïÁûÑÊ∫ñ ‚Ä¢ Â∑¶ÈçµÈªûÊìäÂ∞ÑÊìä
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreDisplay = document.getElementById('finalScore');
    const restartBtn = document.getElementById('restartBtn');

    // Game State
    let gameState = {
        isRunning: true,
        score: 0,
        lastEnemySpawn: 0,
        enemySpawnRate: 1000, // ms
        difficultyMultiplier: 1
    };

    // Assets (using Emojis for simplicity)
    const SPRITES = {
        player: 'üê±',
        gun: 'üî´',
        bullet: 'üí©',
        enemies: ['üêü', 'üß∂', 'üêÅ', 'üê¶'],
        explosion: 'üí•'
    };

    // Player Object
    const player = {
        x: canvas.width / 2,
        y: canvas.height - 80,
        width: 60,
        height: 60,
        angle: 0
    };

    // Arrays to hold game entities
    let bullets = [];
    let enemies = [];
    let particles = []; // For explosion effects

    // Input Handling
    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
    });

    canvas.addEventListener('mousedown', (e) => {
        if (gameState.isRunning) {
            shoot();
        }
    });

    restartBtn.addEventListener('click', resetGame);

    function resetGame() {
        gameState.isRunning = true;
        gameState.score = 0;
        gameState.difficultyMultiplier = 1;
        gameState.enemySpawnRate = 1000;
        bullets = [];
        enemies = [];
        particles = [];
        scoreDisplay.textContent = '0';
        gameOverScreen.style.display = 'none';
        requestAnimationFrame(gameLoop);
    }

    function shoot() {
        // Calculate angle towards mouse
        const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
        
        // Spawn bullet starting from player position
        bullets.push({
            x: player.x,
            y: player.y - 20,
            vx: Math.cos(angle) * 15,
            vy: Math.sin(angle) * 15,
            size: 20
        });
    }

    function spawnEnemy() {
        const size = 40 + Math.random() * 20;
        const x = Math.random() * (canvas.width - size) + size/2;
        
        enemies.push({
            x: x,
            y: -50,
            size: size,
            speed: (1 + Math.random() * 2) * gameState.difficultyMultiplier,
            sprite: SPRITES.enemies[Math.floor(Math.random() * SPRITES.enemies.length)],
            rotation: 0,
            rotSpeed: (Math.random() - 0.5) * 0.1
        });
    }

    function createExplosion(x, y) {
        for (let i = 0; i < 8; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: `hsl(${Math.random() * 60 + 10}, 100%, 50%)` // Fire colors
            });
        }
    }

    function update(deltaTime) {
        if (!gameState.isRunning) return;

        // Increase difficulty slowly
        gameState.difficultyMultiplier += 0.0001;
        
        // Spawn Enemies
        if (Date.now() - gameState.lastEnemySpawn > gameState.enemySpawnRate) {
            spawnEnemy();
            gameState.lastEnemySpawn = Date.now();
            // Cap spawn rate
            gameState.enemySpawnRate = Math.max(300, 1000 - (gameState.score * 10));
        }

        // Update Player (Cat follows mouse horizontally, but stays on ground)
        // Lerp for smooth movement
        player.x += (mouseX - player.x) * 0.1;
        
        // Limit player to screen bounds
        if (player.x < 30) player.x = 30;
        if (player.x > canvas.width - 30) player.x = canvas.width - 30;

        // Calculate gun rotation
        player.angle = Math.atan2(mouseY - (player.y), mouseX - player.x);

        // Update Bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.x += b.vx;
            b.y += b.vy;

            // Remove off-screen bullets
            if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
                bullets.splice(i, 1);
            }
        }

        // Update Enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            e.y += e.speed;
            e.rotation += e.rotSpeed;

            // Check collision with Player (Game Over)
            const distToPlayer = Math.hypot(e.x - player.x, e.y - player.y);
            if (distToPlayer < (e.size/2 + player.width/3)) {
                gameOver();
            }

            // Remove if off screen (missed)
            if (e.y > canvas.height + 50) {
                enemies.splice(i, 1);
                // Optional: Penalize for missing? For now, just let them pass.
            }

            // Check collision with Bullets
            for (let j = bullets.length - 1; j >= 0; j--) {
                let b = bullets[j];
                const dist = Math.hypot(e.x - b.x, e.y - b.y);
                
                if (dist < e.size / 2 + 10) {
                    // Hit!
                    createExplosion(e.x, e.y);
                    gameState.score += 10;
                    scoreDisplay.textContent = gameState.score;
                    
                    enemies.splice(i, 1);
                    bullets.splice(j, 1);
                    break; // Bullet hit this enemy, stop checking other bullets for this enemy
                }
            }
        }

        // Update Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function draw() {
        // Clear Canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Player
        ctx.save();
        ctx.translate(player.x, player.y);
        
        // Draw Gun (behind cat, rotates)
        ctx.save();
        ctx.rotate(player.angle);
        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        // Flip gun if aiming left so it's not upside down
        if (Math.abs(player.angle) > Math.PI / 2) {
            ctx.scale(1, -1);
        }
        ctx.fillText(SPRITES.gun, 30, 0); 
        ctx.restore();

        // Draw Cat
        ctx.font = "60px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(SPRITES.player, 0, 0);
        ctx.restore();

        // Draw Enemies
        enemies.forEach(e => {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.rotate(e.rotation);
            ctx.font = `${e.size}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(e.sprite, 0, 0);
            ctx.restore();
        });

        // Draw Bullets
        bullets.forEach(b => {
            ctx.font = "20px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(SPRITES.bullet, b.x, b.y);
        });

        // Draw Particles
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        });
    }

    function gameOver() {
        gameState.isRunning = false;
        finalScoreDisplay.textContent = gameState.score;
        gameOverScreen.style.display = 'flex';
    }

    function gameLoop() {
        update();
        draw();
        if (gameState.isRunning) {
            requestAnimationFrame(gameLoop);
        }
    }

    // Start
    requestAnimationFrame(gameLoop);

</script>

</body>
</html>
